// src/screens/exercises/word-games/hooks/useWordGames.js - VERSION CORRIG√âE

import { useState, useEffect, useRef, useCallback } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { Animated } from 'react-native';
import { shuffleArray } from '../../../../utils/arrayUtils';

/**
 * üéØ Hook unifi√© pour Word Games - VERSION CORRIG√âE
 * Probl√®mes r√©solus :
 * - Logique de s√©lection d'items cass√©e
 * - Gestion des paires pour matching games
 * - Calcul des scores incorrect
 * - Navigation d√©faillante
 */
const useWordGames = (wordGamesData = null, level = "A1") => {
  
  // =================== ERROR HANDLING HELPER ===================
  const handleStorageError = (error, operation, fallback = null) => {
    console.warn(`Word games storage error in ${operation}:`, error);
    return fallback;
  };

  // =================== STORAGE KEYS ===================
  const STORAGE_KEY = `wordGames_${level}_position`;
  const COMPLETED_KEY = `wordGames_${level}_completed`;
  const SCORES_KEY = `wordGames_${level}_scores`;

  // =================== STATE ===================
  const [currentGameIndex, setCurrentGameIndex] = useState(0);
  const [selectedItems, setSelectedItems] = useState([]);
  const [matchedItems, setMatchedItems] = useState([]);
  const [showFeedback, setShowFeedback] = useState(false);
  const [isCorrect, setIsCorrect] = useState(false);
  const [showResults, setShowResults] = useState(false);
  const [score, setScore] = useState(0);
  const [gameResults, setGameResults] = useState([]);
  const [shuffledOptions, setShuffledOptions] = useState([]);
  const [loaded, setLoaded] = useState(false);
  const [completedGames, setCompletedGames] = useState({});
  const [lastPosition, setLastPosition] = useState(null);
  
  // ‚úÖ AJOUT√â : √âtat pour l'info-bulle des paires incorrectes
  const [showPairFeedback, setShowPairFeedback] = useState(false);
  const [pairFeedbackMessage, setPairFeedbackMessage] = useState('');
  // ‚úÖ SIMPLIFI√â : Plus besoin de pairFeedbackType, seulement pour les erreurs
  
  // ‚úÖ AJOUT√â : √âtat pour contr√¥ler l'affichage du bouton "V√©rifier"
  const [canShowCheckButton, setCanShowCheckButton] = useState(false);

  const isInitialized = useRef(false);

  // =================== COMPUTED VALUES ===================
  const games = wordGamesData?.games || [];
  const totalGames = games.length;
  const currentGame = games[currentGameIndex];

  // =================== ANIMATIONS ===================
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const bounceAnim = useRef(new Animated.Value(1)).current;

  // ‚úÖ CORRIG√â : D√©marrer l'animation fadeAnim quand le composant se charge
  useEffect(() => {
    if (loaded && games.length > 0) {
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 500,
        useNativeDriver: true,
      }).start();
    }
  }, [loaded, games.length, fadeAnim]);

  // =================== DATA LOADING ===================
  useEffect(() => {
    const loadData = async () => {
      try {
        // Charger position sauvegard√©e
        try {
          const savedPosition = await AsyncStorage.getItem(STORAGE_KEY);
          if (savedPosition) {
            const position = JSON.parse(savedPosition);
            setLastPosition(position);
            setCurrentGameIndex(position.currentGameIndex || 0);
          }
        } catch (positionError) {
          handleStorageError(positionError, 'load position');
        }

        // Charger jeux compl√©t√©s
        try {
          const savedCompleted = await AsyncStorage.getItem(COMPLETED_KEY);
          if (savedCompleted) {
            const completed = JSON.parse(savedCompleted);
            setCompletedGames(completed);
          }
        } catch (completedError) {
          handleStorageError(completedError, 'load completed games');
        }

        // Charger scores
        try {
          const savedScores = await AsyncStorage.getItem(SCORES_KEY);
          if (savedScores) {
            const scores = JSON.parse(savedScores);
            setGameResults(scores);
          } else {
            // Initialiser avec des scores par d√©faut
            setGameResults(Array(games.length).fill({
              score: 0,
              maxScore: 0,
              completed: false,
            }));
          }
        } catch (scoresError) {
          handleStorageError(scoresError, 'load scores');
        }

        setLoaded(true);
      } catch (error) {
        console.error('Error loading word games data:', error);
        setLoaded(true); // Charger quand m√™me pour √©viter le blocage
      }
    };

    if (wordGamesData && !isInitialized.current) {
    loadData();
      isInitialized.current = true;
    }
  }, [wordGamesData, games.length]);

  // =================== GAME LOGIC ===================
  
  // ‚úÖ EXTRACTED : Gestion de la s√©lection/d√©s√©lection d'items
  const toggleItemSelection = useCallback((item, index, currentItems) => {
    const newItems = [...currentItems];
    const existingIndex = newItems.findIndex(selected => 
      selected.item.id === item.id && selected.index === index
    );
    
    if (existingIndex >= 0) {
      newItems.splice(existingIndex, 1);
    } else {
      newItems.push({ item, index });
    }
    
    return newItems;
  }, []);

  // ‚úÖ EXTRACTED : Gestion des paires correctes
  const handleCorrectPair = useCallback((first, second) => {
    console.log('‚úÖ Paire correcte trouv√©e !');
    
    const newMatchedItems = [...matchedItems, first, second];
    setMatchedItems(newMatchedItems);
    setSelectedItems([]);
    
    if (newMatchedItems.length > 0) {
      setCanShowCheckButton(true);
    }
  }, [matchedItems]);

  // ‚úÖ EXTRACTED : Gestion des paires incorrectes
  const handleIncorrectPair = useCallback(() => {
    console.log('‚ùå Paire incorrecte !');
    
    setPairFeedbackMessage('‚ùå Paire incorrecte ! Essayez encore...');
    setShowPairFeedback(true);
    
    setTimeout(() => {
      setSelectedItems([]);
      setShowPairFeedback(false);
    }, 3000);
  }, []);

  // ‚úÖ EXTRACTED : Logique de matching games
  const handleMatchingGame = useCallback((item, index) => {
    const newSelectedItems = toggleItemSelection(item, index, selectedItems);
    setSelectedItems(newSelectedItems);

    if (newSelectedItems.length === 2) {
      const [first, second] = newSelectedItems;
      
      if (first.item.originalPair === second.item.originalPair) {
        handleCorrectPair(first, second);
      } else {
        handleIncorrectPair();
      }
    }
  }, [selectedItems, toggleItemSelection, handleCorrectPair, handleIncorrectPair]);

  // ‚úÖ EXTRACTED : Logique de categorization games
  const handleCategorizationGame = useCallback((item, index) => {
    const newSelectedItems = toggleItemSelection(item, index, selectedItems);
    setSelectedItems(newSelectedItems);
  }, [selectedItems, toggleItemSelection]);

  // ‚úÖ REFACTORED : Fonction principale simplifi√©e
  const handleSelectItem = useCallback((item, index) => {
    if (showFeedback || !currentGame) return;

    console.log('üîç DEBUG handleSelectItem:', { item, index, currentGameType: currentGame.type });

    if (currentGame.type === 'matching') {
      handleMatchingGame(item, index);
    } else if (currentGame.type === 'categorization') {
      handleCategorizationGame(item, index);
    }
  }, [showFeedback, currentGame, handleMatchingGame, handleCategorizationGame]);

  // ‚úÖ CORRIG√â : V√©rification des r√©ponses pour categorization games
  const checkAnswer = useCallback(() => {
    if (!currentGame) return;

    if (currentGame.type === 'categorization') {
      // ‚úÖ CORRIG√â : Logique pour categorization games
      const correctWords = currentGame.categories[currentGame.currentCategory] || [];
      const selectedWords = selectedItems.map(item => item.item.text); // ‚úÖ CORRIG√â : item.item.text au lieu de item.item
      
      console.log('üîç DEBUG Categorization:', {
        currentCategory: currentGame.currentCategory,
        correctWords,
        selectedWords,
        selectedItems: selectedItems.map(item => ({ id: item.item.id, text: item.item.text }))
      });
      
      // V√©rifier si tous les mots s√©lectionn√©s sont corrects
      const allCorrect = selectedWords.every(word => correctWords.includes(word));
      const allIncorrect = selectedWords.every(word => !correctWords.includes(word));
      
      // Score bas√© sur la pr√©cision
      const correctCount = selectedWords.filter(word => correctWords.includes(word)).length;
      const incorrectCount = selectedWords.filter(word => !correctWords.includes(word)).length;
      const totalCorrect = correctWords.length;
      
      console.log('üîç Score calculation:', {
        correctCount,
        incorrectCount,
        totalCorrect,
        allCorrect,
        allIncorrect
      });
      
      const score = Math.max(0, Math.round((correctCount - incorrectCount) / totalCorrect * currentGame.maxScore));
      
      setIsCorrect(allCorrect && incorrectCount === 0);
      setScore(score);
      setShowFeedback(true);
      
      if (allCorrect && incorrectCount === 0) {
        // ‚úÖ R√©ponse CORRECTE - Marquer comme compl√©t√©
        console.log('üéâ Categorization correcte !');
        
        // Sauvegarder le r√©sultat
        const newGameResults = [...gameResults];
        newGameResults[currentGameIndex] = {
          score,
          maxScore: currentGame.maxScore,
          completed: true,
        };
        setGameResults(newGameResults);
        
        // Marquer le jeu comme compl√©t√©
        const newCompletedGames = { ...completedGames, [currentGameIndex]: true };
        setCompletedGames(newCompletedGames);
        
        // Sauvegarder
        saveGameProgress();
        
      } else {
        // ‚ùå R√©ponse INCORRECTE - Red√©marrer le jeu automatiquement
        console.log('‚ùå Categorization incorrecte ! Red√©marrage du jeu...');
        
        // Reset du jeu apr√®s un d√©lai
        setTimeout(() => {
          resetCurrentGame();
          setShowFeedback(false);
          setScore(0);
        }, 3000);
      }
    } else if (currentGame.type === 'matching') {
      // ‚úÖ CORRIG√â : Contr√¥le manuel final pour matching games
      console.log('üîç V√©rification manuelle des paires...');
      
      // V√©rifier si toutes les paires sont trouv√©es
      const totalPairs = currentGame.pairs.length;
      const foundPairs = matchedItems.length / 2;
      
      if (foundPairs === totalPairs) {
        // ‚úÖ Toutes les paires sont trouv√©es et correctes !
        console.log('üéâ Toutes les paires sont correctes !');
        setIsCorrect(true);
        setScore(currentGame.maxScore || 10);
      setShowFeedback(true);
        
        // Sauvegarder le r√©sultat
        const newGameResults = [...gameResults];
        newGameResults[currentGameIndex] = {
          score: currentGame.maxScore || 10,
          maxScore: currentGame.maxScore || 10,
          completed: true,
        };
        setGameResults(newGameResults);
        
        // Marquer le jeu comme compl√©t√©
        const newCompletedGames = { ...completedGames, [currentGameIndex]: true };
        setCompletedGames(newCompletedGames);
        
        // Sauvegarder
        saveGameProgress();
        
      } else {
        // ‚ùå Pas toutes les paires trouv√©es - Game over !
        console.log('‚ùå Game over ! Pas toutes les paires trouv√©es');
        setIsCorrect(false);
        setScore(0);
      setShowFeedback(true);
        
        // Reset du jeu apr√®s un d√©lai
        setTimeout(() => {
          resetCurrentGame();
        }, 3000);
      }
    }
  }, [currentGame, selectedItems, matchedItems, gameResults, currentGameIndex, completedGames]);

  // =================== NAVIGATION ===================
  
  const handleNext = useCallback(() => {
    if (showFeedback) {
      setShowFeedback(false);
      setSelectedItems([]);
      setMatchedItems([]);
      
      if (currentGameIndex < totalGames - 1) {
        setCurrentGameIndex(currentGameIndex + 1);
    } else {
      setShowResults(true);
      }
    }
  }, [showFeedback, currentGameIndex, totalGames]);

  const handlePrevious = useCallback(() => {
    if (currentGameIndex > 0) {
      setCurrentGameIndex(currentGameIndex - 1);
      setShowFeedback(false);
      setSelectedItems([]);
      setMatchedItems([]);
    }
  }, [currentGameIndex]);

  const resetGames = useCallback(() => {
      setCurrentGameIndex(0);
      setSelectedItems([]);
      setMatchedItems([]);
      setShowFeedback(false);
      setShowResults(false);
      setScore(0);
        setGameResults(Array(games.length).fill({
          score: 0,
          maxScore: 0,
          completed: false,
        }));
    setCompletedGames({});
  }, [games.length]);

  // =================== UTILITIES ===================
  
  const saveGameProgress = useCallback(async () => {
    try {
      await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify({
        currentGameIndex,
        timestamp: Date.now(),
      }));
      
      await AsyncStorage.setItem(COMPLETED_KEY, JSON.stringify(completedGames));
      await AsyncStorage.setItem(SCORES_KEY, JSON.stringify(gameResults));
    } catch (error) {
      handleStorageError(error, 'save game progress');
    }
  }, [currentGameIndex, completedGames, gameResults]);

  // ‚úÖ CORRIG√â : Pr√©parer les options pour le jeu actuel
  useEffect(() => {
    if (!currentGame) return;

    if (currentGame.type === 'matching') {
      // ‚úÖ CORRIG√â : Cr√©er les bonnes paires avec word et match
      const pairs = currentGame.pairs || [];
      const options = [];
      
      pairs.forEach((pair, pairIndex) => {
        // Ajouter le mot
        options.push({
          id: `word-${pairIndex}`,
          text: pair.word,
          type: 'word',
          originalPair: pairIndex,
          pairId: pairIndex,
        });
        
        // Ajouter la d√©finition/match
        options.push({
          id: `match-${pairIndex}`,
          text: pair.match,
          type: 'match',
          originalPair: pairIndex,
          pairId: pairIndex,
        });
      });
      
      // M√©langer les options
      const shuffled = shuffleArray(options);
      setShuffledOptions(shuffled);
      
    } else if (currentGame.type === 'categorization') {
      // ‚úÖ CORRIG√â : Transformer les cha√Ænes en objets pour categorization games
      const words = currentGame.words || [];
      const options = words.map((word, index) => ({
        id: `word-${index}`,
        text: word,
        type: 'word',
        originalPair: index,
        pairId: index,
      }));
      
      const shuffled = shuffleArray(options);
      setShuffledOptions(shuffled);
    }
    
    // R√©initialiser l'√©tat du jeu
      setSelectedItems([]);
      setMatchedItems([]);
      setShowFeedback(false);
      setScore(0);
  }, [currentGame]);

  // ‚úÖ AJOUT√â : Reset du jeu actuel
  const resetCurrentGame = useCallback(() => {
    if (!currentGame) return;
    
    // R√©initialiser l'√©tat du jeu actuel
    setSelectedItems([]);
    setMatchedItems([]);
    setShowFeedback(false);
    setScore(0);
    
    // Rem√©langer les options
    if (currentGame.type === 'matching') {
      const pairs = currentGame.pairs || [];
      const options = [];
      
      pairs.forEach((pair, pairIndex) => {
        options.push({
          id: `word-${pairIndex}`,
          text: pair.word,
          type: 'word',
          originalPair: pairIndex,
          pairId: pairIndex,
        });
        
        options.push({
          id: `match-${pairIndex}`,
          text: pair.match,
          type: 'match',
          originalPair: pairIndex,
          pairId: pairIndex,
        });
      });
      
      const shuffled = shuffleArray(options);
      setShuffledOptions(shuffled);
    } else if (currentGame.type === 'categorization') {
      // ‚úÖ CORRIG√â : Transformer les cha√Ænes en objets pour categorization games
      const words = currentGame.words || [];
      const options = words.map((word, index) => ({
        id: `word-${index}`,
        text: word,
        type: 'word',
        originalPair: index,
        pairId: index,
      }));
      
      const shuffled = shuffleArray(options);
      setShuffledOptions(shuffled);
    }
  }, [currentGame]);

  // =================== RETURN VALUES ===================

  return {
    // State
    currentGameIndex,
    selectedItems,
    matchedItems,
    showFeedback,
    isCorrect,
    showResults,
    score,
    gameResults,
    shuffledOptions,
    loaded,
    completedGames,
    lastPosition,
    
    // ‚úÖ AJOUT√â : √âtats de feedback des paires
    showPairFeedback,
    pairFeedbackMessage,
    
    // ‚úÖ AJOUT√â : Contr√¥le du bouton de v√©rification
    canShowCheckButton,
    
    // Computed
    games,
    totalGames,
    currentGame,
    
    // Animations
    fadeAnim,
    bounceAnim,
    
    // Handlers
    handleSelectItem,
    checkAnswer,
    handleNext,
    handlePrevious,
    resetGames,
    
    // Utils
    saveGameProgress,
    resetCurrentGame,
  };
};

export default useWordGames;